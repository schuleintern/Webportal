This library provides a toolkit to make working with the H\+T\+TP protocol easier.

Most P\+HP scripts run within a H\+T\+TP request but accessing information about the H\+T\+TP request is cumbersome at least.

There\textquotesingle{}s bad practices, inconsistencies and confusion. This library is effectively a wrapper around the following P\+HP constructs\+:

For Input\+:


\begin{DoxyItemize}
\item {\ttfamily \$\+\_\+\+G\+ET},
\item {\ttfamily \$\+\_\+\+P\+O\+ST},
\item {\ttfamily \$\+\_\+\+S\+E\+R\+V\+ER},
\item {\ttfamily php\+://input} or {\ttfamily \$\+H\+T\+T\+P\+\_\+\+R\+A\+W\+\_\+\+P\+O\+S\+T\+\_\+\+D\+A\+TA}.
\end{DoxyItemize}

For output\+:


\begin{DoxyItemize}
\item {\ttfamily php\+://output} or {\ttfamily echo},
\item {\ttfamily header()}.
\end{DoxyItemize}

What this library provides, is a {\ttfamily Request} object, and a {\ttfamily Response} object.

The objects are extendable and easily mockable.

\subsection*{Build status }

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ branch  }&\textbf{ status   }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ branch  }&\textbf{ status   }\\\cline{1-2}
\endhead
master  &\href{https://travis-ci.org/fruux/sabre-http}{\tt }   \\\cline{1-2}
3.\+0  &\href{https://travis-ci.org/fruux/sabre-http}{\tt }   \\\cline{1-2}
\end{longtabu}


\subsection*{Installation }

Make sure you have \href{http://getcomposer.org/}{\tt composer} installed. In your project directory, create, or edit a {\ttfamily composer.\+json} file, and make sure it contains something like this\+:


\begin{DoxyCode}
\{
    "require" : \{
        "sabre/http" : "~3.0.0"
    \}
\}
\end{DoxyCode}


After that, just hit {\ttfamily composer install} and you should be rolling.

\subsection*{Quick history }

This library came to existence in 2009, as a part of the \href{http://sabre.io/}{\tt {\ttfamily sabre/dav}} project, which uses it heavily.

It got split off into a separate library to make it easier to manage releases and hopefully giving it use outside of the scope of just {\ttfamily sabre/dav}.

Although completely independently developed, this library has a L\+OT of overlap with \href{https://github.com/symfony/HttpFoundation}{\tt Symfony\textquotesingle{}s {\ttfamily Http\+Foundation}}.

Said library does a lot more stuff and is significantly more popular, so if you are looking for something to fulfill this particular requirement, I\textquotesingle{}d recommend also considering \href{https://github.com/symfony/HttpFoundation}{\tt {\ttfamily Http\+Foundation}}.

\subsection*{Getting started }

First and foremost, this library wraps the superglobals. The easiest way to instantiate a request object is as follows\+:


\begin{DoxyCode}
use \mbox{\hyperlink{namespace_sabre_1_1_h_t_t_p}{Sabre\(\backslash\)HTTP}};

include \textcolor{stringliteral}{'vendor/autoload.php'};

$request = HTTP\(\backslash\)Sapi::getRequest();
\end{DoxyCode}


This line should only happen once in your entire application. Everywhere else you should pass this request object around using dependency injection.

You should always typehint on it\textquotesingle{}s interface\+:


\begin{DoxyCode}
\textcolor{keyword}{function} handleRequest(HTTP\(\backslash\)RequestInterface $request) \{

    \textcolor{comment}{// Do something with this request :)}

\}
\end{DoxyCode}


A response object you can just create as such\+:


\begin{DoxyCode}
use \mbox{\hyperlink{namespace_sabre_1_1_h_t_t_p}{Sabre\(\backslash\)HTTP}};

include \textcolor{stringliteral}{'vendor/autoload.php'};

$response = \textcolor{keyword}{new} HTTP\(\backslash\)Response();
$response->setStatus(201); \textcolor{comment}{// created !}
$response->setHeader(\textcolor{stringliteral}{'X-Foo'}, \textcolor{stringliteral}{'bar'});
$response->setBody(
    \textcolor{stringliteral}{'success!'}
);
\end{DoxyCode}


After you fully constructed your response, you must call\+:


\begin{DoxyCode}
HTTP\(\backslash\)Sapi::sendResponse($response);
\end{DoxyCode}


This line should generally also appear once in your application (at the very end).

\subsection*{Decorators }

It may be useful to extend the {\ttfamily Request} and {\ttfamily Response} objects in your application, if you for example would like them to carry a bit more information about the current request.

For instance, you may want to add an {\ttfamily is\+Logged\+In} method to the Request object.

Simply extending Request and Response may pose some problems\+:


\begin{DoxyEnumerate}
\item You may want to extend the objects with new behaviors differently, in different subsystems of your application,
\item The {\ttfamily Sapi\+::get\+Request} factory always returns a instance of {\ttfamily Request} so you would have to override the factory method as well,
\item By controlling the instantation and depend on specific {\ttfamily Request} and {\ttfamily Response} instances in your library or application, you make it harder to work with other applications which also use {\ttfamily sabre/http}.
\end{DoxyEnumerate}

In short\+: it would be bad design. Instead, it\textquotesingle{}s recommended to use the \href{http://en.wikipedia.org/wiki/Decorator_pattern}{\tt decorator pattern} to add new behavior where you need it. {\ttfamily sabre/http} provides helper classes to quickly do this.

Example\+:


\begin{DoxyCode}
use \mbox{\hyperlink{namespace_sabre_1_1_h_t_t_p}{Sabre\(\backslash\)HTTP}};

\textcolor{keyword}{class }MyRequest \textcolor{keyword}{extends} HTTP\(\backslash\)RequestDecorator \{

    \textcolor{keyword}{function} isLoggedIn() \{

        \textcolor{keywordflow}{return} \textcolor{keyword}{true};

    \}

\}
\end{DoxyCode}


Our application assumes that the true {\ttfamily Request} object was instantiated somewhere else, by some other subsystem. This could simply be a call like {\ttfamily \$request = Sapi\+::get\+Request()} at the top of your application, but could also be somewhere in a unittest.

All we know in the current subsystem, is that we received a {\ttfamily \$request} and that it implements {\ttfamily Sabre\textbackslash{}H\+T\+TP\textbackslash{}Request\+Interface}. To decorate this object, all we need to do is\+:


\begin{DoxyCode}
$request = \textcolor{keyword}{new} MyRequest($request);
\end{DoxyCode}


And that\textquotesingle{}s it, we now have an {\ttfamily is\+Logged\+In} method, without having to mess with the core instances.

\subsection*{Client }

This package also contains a simple wrapper around \href{http://php.net/curl}{\tt c\+U\+RL}, which will allow you to write simple clients, using the {\ttfamily Request} and {\ttfamily Response} objects you\textquotesingle{}re already familiar with.

It\textquotesingle{}s by no means a replacement for something like \href{http://guzzlephp.org/}{\tt Guzzle}, but it provides a simple and lightweight A\+PI for making the occasional A\+PI call.

\subsubsection*{Usage}


\begin{DoxyCode}
use \mbox{\hyperlink{namespace_sabre_1_1_h_t_t_p}{Sabre\(\backslash\)HTTP}};

$request = \textcolor{keyword}{new} HTTP\(\backslash\)Request(\textcolor{stringliteral}{'GET'}, \textcolor{stringliteral}{'http://example.org/'});
$request->setHeader(\textcolor{stringliteral}{'X-Foo'}, \textcolor{stringliteral}{'Bar'});

$client = \textcolor{keyword}{new} HTTP\(\backslash\)Client();
$response = $client->send($request);

echo $response->getBodyAsString();
\end{DoxyCode}


The client emits 3 event using \href{https://github.com/fruux/sabre-event}{\tt {\ttfamily sabre/event}}. {\ttfamily before\+Request}, {\ttfamily after\+Request} and {\ttfamily error}.


\begin{DoxyCode}
$client = \textcolor{keyword}{new} HTTP\(\backslash\)Client();
$client->on(\textcolor{stringliteral}{'beforeRequest'}, \textcolor{keyword}{function}($request) \{

    \textcolor{comment}{// You could use beforeRequest to for example inject a few extra headers.}
    \textcolor{comment}{// into the Request object.}

\});

$client->on(\textcolor{stringliteral}{'afterRequest'}, \textcolor{keyword}{function}($request, $response) \{

    \textcolor{comment}{// The afterRequest event could be a good time to do some logging, or}
    \textcolor{comment}{// do some rewriting in the response.}

\});

$client->on(\textcolor{stringliteral}{'error'}, \textcolor{keyword}{function}($request, $response, &$retry, $retryCount) \{

    \textcolor{comment}{// The error event is triggered for every response with a HTTP code higher}
    \textcolor{comment}{// than 399.}

\});

$client->on(\textcolor{stringliteral}{'error:401'}, \textcolor{keyword}{function}($request, $response, &$retry, $retryCount) \{

    \textcolor{comment}{// You can also listen for specific error codes. This example shows how}
    \textcolor{comment}{// to inject HTTP authentication headers if a 401 was returned.}

    \textcolor{keywordflow}{if} ($retryCount > 1) \{
        \textcolor{comment}{// We're only going to retry exactly once.}
    \}

    $request->setHeader(\textcolor{stringliteral}{'Authorization'}, \textcolor{stringliteral}{'Basic xxxxxxxxxx'});
    $retry = \textcolor{keyword}{true};

\});
\end{DoxyCode}


\subsubsection*{Asynchronous requests}

The {\ttfamily Client} also supports doing asynchronous requests. This is especially handy if you need to perform a number of requests, that are allowed to be executed in parallel.

The underlying system for this is simply \href{http://php.net/curl_multi_init}{\tt c\+U\+RL\textquotesingle{}s multi request handler}, but this provides a much nicer A\+PI to handle this.

Sample usage\+:


\begin{DoxyCode}
use \mbox{\hyperlink{namespace_sabre_1_1_h_t_t_p}{Sabre\(\backslash\)HTTP}};

$request = \textcolor{keyword}{new} Request(\textcolor{stringliteral}{'GET'}, \textcolor{stringliteral}{'http://localhost/'});
$client = \textcolor{keyword}{new} Client();

\textcolor{comment}{// Executing 1000 requests}
\textcolor{keywordflow}{for} ($i = 0; $i < 1000; $i++) \{
    $client->sendAsync(
        $request,
        \textcolor{keyword}{function}(ResponseInterface $response) \{
            \textcolor{comment}{// Success handler}
        \},
        \textcolor{keyword}{function}($error) \{
            \textcolor{comment}{// Error handler}
        \}
    ); 
\}

\textcolor{comment}{// Wait for all requests to get a result.}
$client->wait();
\end{DoxyCode}


Check out {\ttfamily \mbox{\hyperlink{asyncclient_8php_source}{examples/asyncclient.\+php}}} for more information.

\subsection*{Writing a reverse proxy }

With all these tools combined, it becomes very easy to write a simple reverse http proxy.


\begin{DoxyCode}
use
    \mbox{\hyperlink{namespace_sabre_1_1_h_t_t_p_1_1_sapi}{Sabre\(\backslash\)HTTP\(\backslash\)Sapi}},
    \mbox{\hyperlink{namespace_sabre_1_1_h_t_t_p_1_1_client}{Sabre\(\backslash\)HTTP\(\backslash\)Client}};

\textcolor{comment}{// The url we're proxying to.}
$remoteUrl = \textcolor{stringliteral}{'http://example.org/'};

\textcolor{comment}{// The url we're proxying from. Please note that this must be a relative url,}
\textcolor{comment}{// and basically acts as the base url.}
\textcolor{comment}{//}
\textcolor{comment}{// If youre $remoteUrl doesn't end with a slash, this one probably shouldn't}
\textcolor{comment}{// either.}
$myBaseUrl = \textcolor{stringliteral}{'/reverseproxy.php'};
\textcolor{comment}{// $myBaseUrl = '/~evert/sabre/http/examples/reverseproxy.php/';}

$request = Sapi::getRequest();
$request->setBaseUrl($myBaseUrl);

$subRequest = clone $request;

\textcolor{comment}{// Removing the Host header.}
$subRequest->removeHeader(\textcolor{stringliteral}{'Host'});

\textcolor{comment}{// Rewriting the url.}
$subRequest->setUrl($remoteUrl . $request->getPath());

$client = \textcolor{keyword}{new} Client();

\textcolor{comment}{// Sends the HTTP request to the server}
$response = $client->send($subRequest);

\textcolor{comment}{// Sends the response back to the client that connected to the proxy.}
Sapi::sendResponse($response);
\end{DoxyCode}


\subsection*{The Request and Response A\+PI\textquotesingle{}s }

\subsubsection*{Request}


\begin{DoxyCode}

\textcolor{keyword}{public} \textcolor{keyword}{function} \_\_construct($method = null, $url = null, array $headers = null, $body = null);

\textcolor{keyword}{function} getMethod();

\textcolor{keyword}{function} setMethod($method);

\textcolor{keyword}{function} getUrl();

\textcolor{keyword}{function} setUrl($url);

\textcolor{keyword}{function} getAbsoluteUrl();

\textcolor{keyword}{function} setAbsoluteUrl($url);

\textcolor{keyword}{function} getBaseUrl();

\textcolor{keyword}{function} setBaseUrl($url);

\textcolor{keyword}{function} getPath();

\textcolor{keyword}{function} getQueryParameters();

\textcolor{keyword}{function} getPostData();

\textcolor{keyword}{function} setPostData(array $postData);

\textcolor{keyword}{function} getRawServerValue($valueName);

\textcolor{keyword}{function} setRawServerData(array $data);

\textcolor{keyword}{function} getBodyAsStream();

\textcolor{keyword}{function} getBodyAsString();

\textcolor{keyword}{function} getBody();

\textcolor{keyword}{function} setBody($body);

\textcolor{keyword}{function} getHeaders();

\textcolor{keyword}{function} getHeader($name);

\textcolor{keyword}{function} setHeader($name, $value);

\textcolor{keyword}{function} setHeaders(array $headers);

\textcolor{keyword}{function} addHeaders(array $headers);

\textcolor{keyword}{function} removeHeader($name);

\textcolor{keyword}{function} setHttpVersion($version);

\textcolor{keyword}{function} getHttpVersion();
\end{DoxyCode}


\subsubsection*{Response}


\begin{DoxyCode}

\textcolor{keyword}{function} getStatus();

\textcolor{keyword}{function} setStatus($status);

\textcolor{keyword}{function} getBodyAsStream();

\textcolor{keyword}{function} getBodyAsString();

\textcolor{keyword}{function} getBody();


\textcolor{keyword}{function} setBody($body);

\textcolor{keyword}{function} getHeaders();

\textcolor{keyword}{function} getHeader($name);

\textcolor{keyword}{function} setHeader($name, $value);

\textcolor{keyword}{function} setHeaders(array $headers);

\textcolor{keyword}{function} addHeaders(array $headers);

\textcolor{keyword}{function} removeHeader($name);

\textcolor{keyword}{function} setHttpVersion($version);

\textcolor{keyword}{function} getHttpVersion();
\end{DoxyCode}


\subsection*{Made at fruux }

This library is being developed by \href{https://fruux.com/}{\tt fruux}. Drop us a line for commercial services or enterprise support. 